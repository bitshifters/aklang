Particle demo
~~~

1) Strip back Mikroreise to simpler framework:
    - Remove unused FX, code, data etc. - DONE
    - Tidy up code and refactor. - DONE

2) Add Luapod back to control particle & emitter vars.
    - Register var with Lua/Rocket track. - DONE
    - Rethink emitter context: - IN PROGRESS
        - Vec3 position
        - Vec3 direction (or use Vec2 pitch/yaw?)
        - Colour - MAKE THIS FOLLOW POS?
        - Size - use circle plot! <= MODE 9 not MODE 13 => DONE
    - 2D particles only?
    - Register the emitter and drive from Lua. - DONE

3) Rendering investigations.
    - Plot as preshifted 8x8 sprites => 320 tinted.
    - Don't need to tint at run-time, just pre-tint sprites. => needs mask tho.
    - Have a sprite (sheet) index instead of tint value etc. - DONE-ISH
    - Animation frames! - DONE-ISH
    - Try additive plotting of single colour sprites... - DONE
    - Plotting with Z perspective.

4) Improvements to particle & emitter system
    - Emitter iteration function?
        - Do we need to emit more than one particle per frame? - SUPPORTED
        - Called after each particle is spawned? - DONE
    
    - Particle update function? => WAIT FOR RHINO CONCEPTS IN BLENDER?
        - Called for each particle tick to update size/colour etc.?
        - Should be fixed per emitter, otherwise too expensive.
        - Most likely will have to be baked into code.
        - Additional forces (wind etc.?)

5) Particle collision :)
    - Use circle plotting for smaller number of larger objects. - DONE
    - Sort by Y value, determine min/max Y values. - DONE
    - Resolve collisions in a double loop; for each particle: - DONE
        - Find all collision candidates with min/max y.
        - Calculate distance between particles and test radius.
        - Calculate collision axis.
        - Push particles apart with a damping factor.
        - Calculate collision forces with a damping factor.

6) Make a demo!
    - Prototype FX until Christmas or so.
    - Pick a theme for the demo (perhaps all particles and save 3D?)
    - Aim for 64K demo at Revision? If not, NOVA.
        - Good compression on the exe ~8K for all particle prototypes so far.
        - QTM RModule comes down to <12K as a last resort!
        - Chiptune MOD from 32K down to ~6K.
    - Get Steve to cut down QTM (strip out SWIs etc.)


MISSING framework features:
~~~
- Add arbitrary tick/task functions (with self-remove?) e.g. screen fades. - DONE.
- Background task functions that are preempted by rendering. e.g. decompress. => WHEN NEEDED.
- Sort out ye olde palette code.  => WHEN NEEDED.
    - Direct VIDC write fns for palette changes.
    - Palette pending to sync palette changes on vsync.
- Fast debug print to screen. - DONE
- Steve's suggestion of reprogramming the pointer sprite for debug?!
- Debug lines? (Will be slow but useful.)
    - List of 2D lines to plot.
    - Helper fn. to plot debug lines in 3D.
- URGENT ==> Remove dependency on Lua for runtime. <==
- Deal with frame count vs vsync count discrepancy.
    - What do we want to script in? Frames (shown) or seconds?
    - If timed exactly to music then needs to be in vsyncs/seconds.
    - Move to fixed point seconds anyway as music patterns are not whole vsyncs?
        Can't actually represent 1/50 in [0.16] = 1310.72 -- Doh!
        But would only lose 0.04s across 3 minutes so probably OK...
        If we cared about losing a frame or two across the demo then
        just correct the absolute time every 4000 frames or such, just
        before the error > 1/50.


TODO Particles ==> Pending concept?
~~~
- Lua export to tables or whatever runtime solution. - FOR NOW (MATH EMITTER)
- Sprite sheets for animated particles. - STARTED
- Plot particles in 3D.
- Select sprite from sheet when plotting in 3D for depth.
- Specific particle FX if Dave hasn't given us some: (Use Processing?)
    - Smoke
    - Vortex
- Some math_emitter functions might want to be f(t) not f(i)?
    E.g. perhaps the position stays the same but the direction & colour
         are updated for multiple particles per tick.


TODO Balls ==> Pending concept?
~~~
- Add bouyancy?
- Add lifetime to balls then pop?
    - Send pop force to nearby / touching balls.
    - Produce particles.
    - Make smaller balls?
- Plot as sprites or fixed circle draw fns.
- Plot as ellipses (separate radii for X&Y) and animate wobble?


TODO 3D
~~~
- Python script to convert OBJs to runtime binary format.
- Renderqueue for drawing more complex 3D objects with sorted faces.
- Add multiple lights to the scene.
    - Time for MODE 13?!?!
    - Reprogram 16 colour palette if <16 faces?
- Render multiple objects in the scene.
- Screen clipping.
- Object outline => copying Sarah's idea, so not yet!
    - All faces have an edge list.
    - Count how many times each edge is used when plotting faces.
    - For any edge that has a count of 1, draw this edge as a black line.
- More interesting platonic shapes for reference and perf testing.
- Morphing.


TODO Font
~~~
- Investigate RISCOS font library.
    - Three fonts always available? - YEP
    - Wrapper to plot words and copy out as sprites. - DONE
    - Use VDU type codes for position & size etc.?
- Implement a minimal !Draw file renderer?
    - See RISCOS PRMs pp.4-457 for file format specification.
    - Just need to implement FontTable and TextObject objects.
    - The rest can be skipped over.
    - Main complexity will be converting coordinates.
    - Could easily be reused for size constrained intro, greets, credits etc.


Timing on ARM2.
~~~
- Tinted circles (radius 2-14 pixels) ~= 50
- Tinted 8x8 sprites (radius ~3.5) ~= 350
- Tinted pixels (radius 0) ~= 600
- Additive 8x8 sprites (radius ~3.5) ~= 170
- Full ball collision (radius 4-24) ~= 20


LUA vs runtime
~~~
Examples:
    emitter.pos.x = 100.0 * math.sin(fram / 60)
    emitter.pos.y = 128.0 + 60.0 * math.cos(f/80)
    emitter.colour = (emitter.colour + 1) & 15
    emitter.radius = 8.0 + 6 * math.sin(f/10)
    emitter.dir.x = 2.0 * math.sin(f/100)
    emitter.dir.y = 1.0 + 5.0 * math.random() --0.0 * math.cos(f/100)

Table?
    -- f/60 cycles at 60*2*PI~=377 frames.
    -- f/80 cycles at 80*2*PI~=502 frames.
    -- f/10 cycles at 10*2*PI~=63 frames.
    -- f/100 cycles at 100*2*PI~=628 frames.
    -- What precision do we need for each track? (Easier if full word.)
    -- We have a large, high precision SINUS table in RAM.
    -- Could calculate tracks using a fairly standard formula here.
    -- v = a + b * f(c + d * i)
    -- Where a, b, c are constants, f = sin, cos, rand, etc.
    -- And i=frame or i=vsync or i+=1 per emission.
    -- colour = i & 15
    -- Kinda want to write it in some Rose like code and have it JIT'd!?!
    -- Depends how all-in we want to go with sophisticated particle systems.

To consider:
 This all kind of begs for some sort of simple (Rose-like?) scripting
 language that can perform a set of maths operations on structures in an optimal way.
 Ideally this would resolve to a bytecode (for size) and then be JIT'd
 to machine code at init (for speed).
 Define a struct, operate on elements in a struct that are either ints
 or fixed_point, call a limited set of functions with various params,
 define your own functions that take parameters etc.
==>  Is this just C?!?!?


https://archi.medes.live/#preset=a3000&disc=https://bitshifters.github.io/content/wip/verse-particles,ddc&autoboot=desktop%20filer_run%20hostfs::hostfs.$.!Verse&soundfilter=2
https://archi.medes.live/#preset=a3000&disc=https://bitshifters.github.io/content/wip/verse-balls,ddc&autoboot=desktop%20filer_run%20hostfs::hostfs.$.!Verse&soundfilter=2
