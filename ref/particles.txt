Particle demo
~~~

1) Strip back Mikroreise to simpler framework:
    - Remove unused FX, code, data etc. - DONE
    - Tidy up code and refactor. - DONE

2) Add Luapod back to control particle & emitter vars.
    - Register var with Lua/Rocket track. - DONE
    - Rethink emitter context: - IN PROGRESS
        - Vec3 position
        - Vec3 direction (or use Vec2 pitch/yaw?)
        - Colour - MAKE THIS FOLLOW POS?
        - Size - use circle plot! <= MODE 9 not MODE 13 => DONE
    - 2D particles only?
    - Register the emitter and drive from Lua. - DONE

3) Rendering investigations.
    - Plot as preshifted 8x8 sprites => 320 tinted.
    - Don't need to tint at run-time, just pre-tint sprites. => needs mask tho.
    - Have a sprite (sheet) index instead of tint value etc. - DONE-ISH
    - Animation frames! - DONE-ISH
    - Try additive plotting of single colour sprites... - DONE
    - Plotting with Z perspective.

4) Improvements to particle & emitter system
    - Emitter iteration function?
        - Do we need to emit more than one particle per frame? - SUPPORTED
        - Called after each particle is spawned? - DONE
    
    - Particle update function? => WAIT FOR RHINO CONCEPTS IN BLENDER?
        - Called for each particle tick to update size/colour etc.?
        - Should be fixed per emitter, otherwise too expensive.
        - Most likely will have to be baked into code.
        - Additional forces (wind etc.?)

5) Particle collision :)
    - Use circle plotting for smaller number of larger objects. - DONE
    - Sort by Y value, determine min/max Y values. - DONE
    - Resolve collisions in a double loop; for each particle: - DONE
        - Find all collision candidates with min/max y.
        - Calculate distance between particles and test radius.
        - Calculate collision axis.
        - Push particles apart with a damping factor.
        - Calculate collision forces with a damping factor.

6) Make a demo!
    - Prototype FX until Christmas or so.
    - Pick a theme for the demo (perhaps all particles and save 3D?)
    - Aim for 64K demo at Revision? If not, NOVA.
        - Good compression on the exe ~8K for all particle prototypes so far.
        - QTM RModule comes down to <12K as a last resort!
        - Chiptune MOD from 32K down to ~6K.
    - Get Steve to cut down QTM (strip out SWIs etc.) - ASKED!


MISSING framework features:
~~~
- Add arbitrary tick/task functions (with self-remove?) e.g. screen fades. - DONE.
- Background task functions that are preempted by rendering. e.g. decompress. => WHEN NEEDED.
- Sort out ye olde palette code.  => WHEN NEEDED.
    - Direct VIDC write fns for palette changes.
    - Palette pending to sync palette changes on vsync.
- Fast debug print to screen. - DONE
- Steve's suggestion of reprogramming the pointer sprite for debug?!
- Debug lines? (Will be slow but useful.)
    - List of 2D lines to plot.
    - Helper fn. to plot debug lines in 3D.
- URGENT ==> Remove dependency on Lua for runtime. <==
- Deal with frame count vs vsync count discrepancy.
    - What do we want to script in? Frames (shown) or seconds?
    - If timed exactly to music then needs to be in vsyncs/seconds.
    - Move to fixed point seconds anyway as music patterns are not whole vsyncs?
        Can't actually represent 1/50 in [0.16] = 1310.72 -- Doh!
        But would only lose 0.04s across 3 minutes so probably OK...
        If we cared about losing a frame or two across the demo then
        just correct the absolute time every 4000 frames or such, just
        before the error > 1/50.


TODO Particles ==> Pending concept?
~~~
- Lua export to tables or whatever runtime solution. - FOR NOW (MATH EMITTER)
- Sprite sheets for animated particles. - STARTED
- Plot particles in 3D. ==> stick with 2D for now.
- Select sprite from sheet when plotting in 3D for depth.
- Specific particle FX if Dave hasn't given us some: (Use Processing?)
    - Smoke ==> no gravity, low +ve y vel, random x vel.
    - Vortex ==> tangential accel.
    - Repulsion ==> gravitational fields are f(r^2) IIRC. - DONE
        if len < radius then f=M / |d|^2
        YES: F = G * m1 * m2 / |p2-p1|^2
             But constrain the distance to [min,max] value first.
        Because of fixed point arthimetic, large numbers (squares) don't play nice.
        Will need to think about how to handle the precision here.
        This is where I could do with prototyping in C...
    - Circular collider:
         d  = particle_pos - object_centre
        |d| = sqrt(dx*dx + dy*dy)
         D  = d / |d|                normalised direction vector.
        if len > radius then f=0
    - TODO: Reduce duplicated code.
    - Hook's Spring Law:
        fa = - [ks.(dist-r) + kd.(va-vb).norm_dir].norm_dir
      For two particles with velocity va, vb, position pa, pb dir=pa-pb, dist=|dir|, norm_dir = dir/dist
      ks = spring constant, kd = spring damping
      r = rest length.
      Don't need this for returning a particle to it's origin, just f=-k.dist

- Some math_emitter functions might want to be f(t) not f(i)?
    E.g. perhaps the position stays the same but the direction & colour
         are updated for multiple particles per tick.


TODO Balls ==> Pending concept?
~~~
- Add buoyancy?
    - Just increasing drag plus an upwards force related to density.
        F = p V g
        Where p = density of fluid (kg/m^3) (water=1000kg/m^3=1g/cm^3)
              V = [submerged] volume of the object (sphere = 4/3 pi r^3)
              g = acceleration due to gravity
- Add lifetime to balls then pop?
    - Send pop force to nearby / touching balls.
    - Produce particles.
    - Make smaller balls?
- Plot as sprites or fixed circle draw fns.
- Plot as ellipses (separate radii for X&Y) and animate wobble?


TODO 3D
~~~
- Python script to convert OBJs to runtime binary format.
- Renderqueue for drawing more complex 3D objects with sorted faces.
- Add multiple lights to the scene.
    - Time for MODE 13?!?!
    - Reprogram 16 colour palette if <16 faces?
- Render multiple objects in the scene.
- Screen clipping.
- Object outline => copying Sarah's idea, so not yet!
    - All faces have an edge list.
    - Count how many times each edge is used when plotting faces.
    - For any edge that has a count of 1, draw this edge as a black line.
- More interesting platonic shapes for reference and perf testing.
    - I think these were on Zarchos's A3000?!?!

- Morphing.

- Simple soft-body system?
    N (<10) particles that are interconnected and apply force to each other?
    As per https://paulbourke.net/miscellaneous/particle/ and particlelib.c
    Perhaps better as a 3D object (with glenz rendering?)
- Or do this in 2D only and render as...?


TODO Font
~~~
- Investigate RISCOS font library.
    - Three fonts always available? - YEP
    - Wrapper to plot words and copy out as sprites. - DONE
    - Use VDU type codes for position & size etc.?
- Implement a minimal !Draw file renderer? - DONE
    - See RISCOS PRMs pp.4-457 for file format specification.
    - Just need to implement FontTable and TextObject objects.
    - The rest can be skipped over.
    - Main complexity will be converting coordinates.
    - Could easily be reused for size constrained intro, greets, credits etc.
    - Could be extended for Path Objects and Transformed Text Objects etc.


Timing on ARM2.
~~~
- Tinted circles (radius 2-14 pixels) ~= 50
- Tinted 8x8 sprites (radius ~3.5) ~= 350
- Tinted pixels (radius 0) ~= 600
- Additive 8x8 sprites (radius ~3.5) ~= 170
- Full ball collision (radius 4-24) ~= 20
- Spring grid as pixels ~= 256


LUA vs runtime
~~~
Examples:
    emitter.pos.x = 100.0 * math.sin(fram / 60)
    emitter.pos.y = 128.0 + 60.0 * math.cos(f/80)
    emitter.colour = (emitter.colour + 1) & 15
    emitter.radius = 8.0 + 6 * math.sin(f/10)
    emitter.dir.x = 2.0 * math.sin(f/100)
    emitter.dir.y = 1.0 + 5.0 * math.random() --0.0 * math.cos(f/100)

Table?
    -- f/60 cycles at 60*2*PI~=377 frames.
    -- f/80 cycles at 80*2*PI~=502 frames.
    -- f/10 cycles at 10*2*PI~=63 frames.
    -- f/100 cycles at 100*2*PI~=628 frames.
    -- What precision do we need for each track? (Easier if full word.)
    -- We have a large, high precision SINUS table in RAM.
    -- Could calculate tracks using a fairly standard formula here.
    -- v = a + b * f(c + d * i)
    -- Where a, b, c are constants, f = sin, cos, rand, etc.
    -- And i=frame or i=vsync or i+=1 per emission.
    -- colour = i & 15
    -- Kinda want to write it in some Rose like code and have it JIT'd!?!
    -- Depends how all-in we want to go with sophisticated particle systems.

To consider:
 This all kind of begs for some sort of simple (Rose-like?) scripting
 language that can perform a set of maths operations on structures in an optimal way.
 Ideally this would resolve to a bytecode (for size) and then be JIT'd
 to machine code at init (for speed).
 Define a struct, operate on elements in a struct that are either ints
 or fixed_point, call a limited set of functions with various params,
 define your own functions that take parameters etc.
==>  Is this just C?!?!?


https://archi.medes.live/#preset=a3000&disc=https://bitshifters.github.io/content/wip/verse-particles,ddc&autoboot=desktop%20filer_run%20hostfs::hostfs.$.!Verse&soundfilter=2
https://archi.medes.live/#preset=a3000&disc=https://bitshifters.github.io/content/wip/verse-balls,ddc&autoboot=desktop%20filer_run%20hostfs::hostfs.$.!Verse&soundfilter=2


2024
~~~

Dave's thought:
"So the ideas I have for particles mostly revolve around them having a relationship to some other key object (the character in a story, I suppose)"

- Perhaps make the ball our key character that connects everything together?
- This stops it being a random set of effects strung together.
- Instead the ball is always on screen and the demo is its journey.
    - Ball is (almost) always the same colour and size?
    - Other balls always have a different colour.
- In an ideal world the ball would have some sort of 'character' imbued from it's motion.
  (Think 'Thomas Was Alone'...) Although this is very hard to do well!
- Scene transitions can be triggered by the ball.
    - Exit one side <scene changes> enter same side or a different one.

Potential sequence w/ ball as character.

1. Progress bar can be an expanding circle that fills the screen.
   When precalc is complete it pops back to its default size to begin.

2. Introduce our character, the ball.
    - What's the setting? Empty screen or is there a floor/walls etc.?
    - Ball bounces (ideally collisions are sync'd to beats)
    - Throw ball at wall(s).
    - Ball rolls off screen.

3. Ball as the emitter (having fun)
    - Ball moves in nice lissajous patterns emitting fun particles.
    - Ball spins in a circle to create a vortex.
    - Etc.
    - Q. Does the ball pick up the emitter cf. the fire?
    - Q. What's the background?

4. Ball on fire (!)
    - Enter a screen with a small fire effect.
    - Ball rolls over the effect and becomes the emitter.
    - Ball moves in more erratic motions with fire/smoke effect.

4. Rain
    - Enter a screen with rain particles falling from above.
    - Rain particles collide with the ball and put the fire out.
    - Ball moves around the rain leaving nice gap underneath.

5. Jar
    - Ball falls into a jar.
    - Other balls fall in (but they're a different colour).
    - Balls of the same size that collide do the pop thing.
    - Eventually the bottom falls out of the jar everything leaves.

6. Greets
    - Just text names with the balls falling down on them from the jar above?
    - Q. How are collisions done?

7. Credits
    - Name assembles as spring constrained particles.
    - Ball appears (falling from above?) and repulses them.
    - Ball moves around to mess up the name
    -  and the particles reassemble with a new name each time.

8. Group name / logo?
    - Static Torment logo with ball bouncing in place of the 'o'?
    - Static Bitshifters logo will ball bouncing on the i?
    - Q. is this at the end or could be at the beginning?

9. End
    - Ball comes to a stop.
    - Ball expands then contracts to a point.


Global:
    - Need a nice colour scheme
        - Bright and fun or dark & moody? :D
    - Show a particle counter in the bottom right throughout?
    - Any text intermissions to explain or let the visuals speak?
    - Assume no 3D effects in this one, i.e. no vectorballs?


Ball
~~~
- Single instance (?) special particle (until we need the multi-ball collision).
- Position, velocity, accumulate force.
- Use script to set up the world (collisions etc.)
    - Add plane, add line?
- Use script to move the ball
    - Set position (kinematic)
    - Set velocity
    - Set constant force (gravity or wind etc.)
    - Send impulse force
- Q? Would this be better / quicker to script in Lua?
